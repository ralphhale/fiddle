@page "/materialtypes"
@using IndustrialLighting.Domain.Services
@using IndustrialLighting.Persistence.Entities

@inject NavigationManager navigationManager
@inject MaterialTypeService materialTypeService

<PageTitle>Material Types</PageTitle>

<MudText Typo="Typo.h2">Material Types</MudText>

<MudText Typo="Typo.body1">Manage your list of material type categories here</MudText>

@if (isLoading)
{
    <MudProgressCircular Color="Color.Success" Style="height:70px;width:70px;" Indeterminate="true" />
}
else
{
    <MudButton Class="mt-8 mb-8" Variant="Variant.Filled" Color="Color.Primary" Href="/materialtype">Create a Material Type</MudButton>

    <MudTable Items="@materialTypes" Hover="true" Breakpoint="Breakpoint.Sm" @ref="mudTable" T="MaterialType">
        <HeaderContent>
            <MudTh>Name</MudTh>
            <MudTh>Edit</MudTh>
            <MudTh>Delete</MudTh>
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Name">@context.Name</MudTd>
            <MudTd>
                <MudIconButton Href=@($"/materialtype/{context.Id}") Icon="@Icons.Custom.Uncategorized.Bacteria" Size="Size.Large" Color="Color.Warning"></MudIconButton>
            </MudTd>
            <MudTd>
                <MudIconButton OnClick="OnDeleteClick" Icon="@Icons.Custom.Uncategorized.Radioactive" Size="Size.Large" Color="Color.Error"></MudIconButton>
            </MudTd>
        </RowTemplate>
    </MudTable>
}

@code {
    private bool isLoading = true;
    private List<MaterialType>? materialTypes;
    private MudTable<MaterialType> mudTable;

    protected override async Task OnInitializedAsync()
    {
        materialTypes = await materialTypeService.ListAsync();

        isLoading = false;
    }

    private async Task OnDeleteClick()
    {
        //try
        //{
        //    canSave = false;
        //    canCancel = false;

        //    await materialTypeService.CreateAsync(materialType.Name);

        //    snackbarService.Add($"Material type {materialType.Name} was added successfully", Severity.Success);

        //    canCancel = true;
        //    cancelTtext = "Close";
        //}
        //catch (ValidatorException vex)
        //{
        //    Errors = vex.Errors;

        //    canSave = true;
        //    canCancel = true;
        //}
        //catch (Exception ex)
        //{
        //    snackbarService.Add(ex.Message, Severity.Error);

        //    canSave = true;
        //    canCancel = true;
        //}
    }
}
